# Lab1

__林文浩 PB21050974__

#### P1000 快速排序

参考了作业题里的伪代码，使用双指针，对每个递归调用，取区间的中间元素为pivot（这种取法在完全顺序和完全逆序中都有不差的表现），首先将pivot元素交换到最后一个位置（为了方便前面元素的分开），然后双指针分别从剩下元素的最前面和最后面向中间推进，当遇到不应该被分到左(右)区间的元素则停下，然后交换两元素，循环直到两指针相遇，最后再把pivot交换回来，对左右区间递归调用快排。

#### P1001 序列合并

使用了堆，用于在logn时间内插入和Pop堆顶元素。将n^2个和按照下标排成n行，则每行的前面大于后面的值（竖着也一样，但是这里只需要用到一边），所以维持堆里的元素为每行首个还未输出的和，就能保证堆里存在还未输出的和中的最小值，每次输出堆顶元素之后，从同一行补充一个元素插入堆中（前提是该行还有元素），输出n个元素共需要n次入堆和n次出堆，所以是2nlogn，即O(nlogn)

#### P1002 成绩排名

先处理一下学生的姓名，将字符串里的\n去掉，后面都改成char(96)，即比a(97)小，从而每个人的字符串都有10个能被排序的数字，然后对名字从后往前用96~122一共27个桶进行桶排序，再对数学和算法用101个桶进行排序，注意排序的是学生的index，以避免大量数据拷贝，最后根据index输出学生姓名。

#### P1003 上升序列

个人认为这次最难的一题，参考网上求逆序对数量的题，使用了树状数组（Binary Index Tree, BIT），该数组利用二进制数的性质做了一个类似二叉树的结构，使得树状数组能在logn时间内访问某个元素的值、计算某个区间的和、修改某元素的值。A为题目给的数组，B为新建一个相同大小的BIT数组，BIT所有元素初始都为0，遍历数组A，每次将BIT[A[i]]设为1，表示已经访问过，logn内可以计算BIT[A[i]]之前所有元素之和(一堆0和一堆1)，得到的是排在A[i]之前且小于A[i]的元素个数low，有了这个值后也同时能算出排在A[i]之后且大于A[i]的元素个数high，这两个数相乘就是以A[i]为中心可以组成的顺序三元组的数量。所以总时间是nlogn。

~~~c++
BIT B(n);//B初始全为0，遍历数组A，若A[i]=x,则将B[x] = 1
for (int i = 1;i <= n;i++)
{
	long long low = B.Sum(A[i] - 1);//排在A[i]之前，且比它小的元素个数
	long long high = n - A[i] - i + 1 + low;//排在A[i]之后，且比它大的元素个数
	num += low * high;//low * high为以A[i]为中心的升序三元组的数量
	B.Revise(A[i], 1);
}
printf("%lld", num);
~~~

