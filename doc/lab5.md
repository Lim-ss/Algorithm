# Lab5

__林文浩 PB21050974__

#### P1013 全源最短路

由于图中可能存在负环，因此需要先用BellmanFord判断是否有负环，是则输出-1，然后根据n的范围决定使用Floyd还是Johnson算法，需要注意的是可能有重边，由于我们找的是最短路径因此只要最小的一条。在Floyd的情况下，初始化邻接矩阵时取min值就行，在Johnson的情况下，由于其本质上用的是改进后的dijkstra，因此有重边不影响最终结果，使用可以不管，照样把重边加进来。注意使用johnson算法时，需要对边进行reweight，否则负边会导致dijkstra失效。

#### P1014 01单源最短路

由于边权只有$0$和$1$，所以可以使用简化的dijkstra算法，其中在边缘集合Q中寻找到已扩展集合S的最小距离的步骤得以简化，因为这个距离要么是$0$要么是$1$，因此只需维护两个数组分别为$Zero$和$One$，并且给每个顶点一个状态量，状态可以是_zero_、_one_，表示处在$Zero$或者$One$数组中，也可以是_visited_，表示已经被加入S中，也可以是_infinity_，表示还未被探索，每次从优先从Zero数组随便挑出一个顶点加入S，并更新与它邻接的顶点的状态，并根据需要接入$Zero$或$One$中。其中，如果某个顶点已经在$One$中，此时需要更新为_zero_状态，则直接加入$Zero$中，无需从$One$数组中将其删去，因为只需要在每次Pop的时候检查顶点的状态，确定其没有失效即可，如果失效了则直接丢弃。由于每个顶点只会被添加到S一次，每条边仅会在出发顶点被添加到S时访问一次，因此总体时间复杂度为$O(n+m)$

#### P1015 强连通分量

使用经典的tarjan算法，即使用在进行DFS时利用时间戳更新顶点的dfn和low属性，其中dfn是该顶点首次被探索到时的时间，而low通过回溯更新最终等于强连通分量子树的根节点的dfn，最终low相同的节点即为一个强连通分量，这个方法和老师上课讲的逆转边的方向的方法有点不同，但思想类似。由于算法大体是一个DFS，因此时间复杂度为$O(n+m)$

#### P1016 翻新道路

没想到什么好的优化方法，直接DFS递归暴力求出生成树的大小
